# 各类垃圾回收器总结

## 串行GC
> 启用参数：-XX:+UseSerialGC
* GC算法
    1. 年轻代GC算法：mark-copy算法
    2. 老年代GC算法：mark-sweep-compact算法
* 优点
    1. 简单高效，在单个 CPU 环境下，由于没有线程交互的开销，因此拥有最高的单线程收集效率
* 缺点
    1. 不能充分利用多核CPU，在多核CPU机器上会导致资源闲置
    2. 由于单线程，所以youngGC和fullGC都会触发全线暂停
* 适用场景
    1. 适合几百M堆内存的JVM
    2. 而且是单核CPU
    

## 并行GC
> 启用参数：  
-XX:+UseParallelGC  
-XX:+UseParallelOldGC  
-XX:+UseParallelGC   
-XX:+UseParallelOldGC  
* GC算法
    1. 年轻代GC算法：mark-copy算法
    2. 老年代GC算法：mark-sweep-compact算法
* 优点
    1. 在GC期间，所有CPU内核都在并行清理垃圾，所以STW时间更短。
    2. 在2次GC期间，没有GC线程运行，不会消耗任何系统资源
* 缺点
    1. 在单核环境下不如串行gc
    2. 并行gc容易出现长时间卡顿
* 适用场景
    1. 多核CPU服务器
    2. 对系统吞吐量要求高的场景

## CMS
> 启用参数：-XX:+UseConcMarkSweepGC 
* GC算法
    1. 年轻代GC算法：mark-copy算法
    2. 老年代GC算法：mark-sweep算法
* GC阶段
    1. 初始标记（STW）
        1. 初始标记的目标是根对象直接引用的老年代对象，以及被年轻代中所有存活对象所引用的老年代对象
    2. 并发标记
        1. GC遍历老年代，标记所有存活对象，从前一阶段"初始标记"找到的根对象开始算起
        2. 注意：并发标记过程中，对象引用关系还是会发生变化
    3. 并发预清理
        1. 如果在并发标记阶段，对象引用关系发生了变化，JVM会通过"CARD"的方式将发生了变化的区域标记为"脏"区（卡片标记）
        2. 脏对象会被统计出来，它们的引用对象也会被标记
    4. 可中止的并发预清理
        1. 本阶段尝试在最终标记之前尽可能多做一些工作。
        2. 循环做同样的工作，直到满足某个退出条件（循环次数，有用工作量，消耗的系统时间）
    5. 最终标记(STW)
        1. 本阶段的目标是完成老年代中所有存活对象的标记
        2. 因为之前的预清理阶段是并发执行的，有可能GC线程跟不上应用程序修改的速度，所以需要一次STW暂停来处理各种复杂的情况
    6. 并发清理
        1. JVM在此阶段并发的删除不再使用的对象，并回收它们占用的内存空间
    7. 并发重置
        1. 重置CMS算法相关的内部数据，为下一次GM循环做准备
* 优点
    1. 避免在老年代GC发生长时间卡顿。
* 缺点
    1. 由于CMS会在应用程序运行过程中并行执行垃圾清理，将默认占用cpu核数的1/4，因此吞吐量比并行GC低
    2. 老年代内存碎片化问题
* 适用场景
    1. 多核CPU服务器
    2. 主要调优目标是降低GC导致的系统延迟场景
# G1
> 启用参数：  
-XX:+UseG1GC  
-XX:MaxGCPauseMillis=50 
* GC特点
    1. 堆不再分为年轻代和老年代，而是划分为多个可以存放对象的小块。每一个小块，可能一会儿被定义成Eden区，一会被指定为Survivor区，一会儿被指定为Old区
    2. 不必每次都去收集整个堆内存空间，而是以增量的方式来进行处理，每次只处理一部分内存块
    3. 每次GC暂停都会收集所有年轻代的内存块，但一般只包含部分老年代的内存块
    4. 并发阶段估算每个小块存活对象的总数，垃圾最多的小块被优先收集
* GC阶段
    1. 年轻代模式转移暂停
        1. G1会通过前面一段时间的运行情况来不断调整自己的回收策略和行为，以此来比较稳定的控制暂停时间
        2. 在应用程序刚启动时，处于初始的fully-young模式
        3. 当年轻代空间用满后，应用线程会被暂停。年轻代对象会被copy到存活区，如果现在还没有存活区，则任意选择一部分空闲内存块作为存活区
    2. 并发标记
        1. 初始标记
            1. 标记所有从GC根对象直接可达的对象，通常是在转移暂停的同时处理这些事情，因此开销很小
        2. Root区扫描
            1. 此阶段标记所有从"根区域"可达的存活对象
        3. 并发标记
            1. 类似CMS的并发标记，只遍历对象图，并在一个特殊的位图中标记能访问到的对象
        4. 再次标记
            1. 这是一次STW停顿。标记所有在并发标记阶段未被标记的存活对象。
        5. 清理
            1. 统计小堆块中的存活对象，并将小堆块进行排序，以提高GC效率 
    3. 转移暂停
        1.并发标记完成后，G1将执行一次混合收集，就是不只清理年轻代，还将一部分老年代区域也加入到回收集中
* 优点
    1. 暂停时间可预测
    2. 终结了堆内存的碎片化
* 缺点
    1. 由于额外的写屏障和守护线程，G1开销会更大
* 适用场景
    1. 大内存场景
    2. 要求低延迟的场景
## ZGC
> 启用参数：  
-XX:+UnlockExperimentalVMOptions  
-XX:+UseZGC

* GC阶段
    1. 暂停-标记开始阶段：第一次暂停，标记根对象集合r指向的对象
    2. 并发标记/重映射阶段：遍历对象图结构，标记对象
    3. 暂停-标记结束阶段：第二次暂停，同步点，弱根对象清理
    4. 并发准备重定位阶段：引用处理、弱对象清理
    5. 暂停-重定位开始阶段：第三次暂停，根对象指向重定向集合
    6. 并发重定位阶段：重定向集合中的对象重定向
* 优点
    1. GC最大停顿时间不超过10ms，与G1相比，改进非常大
    2. 堆内存支持范围广，从几百M到4T的内存
* 缺点
    1. 与G1相比，吞吐量有所下降
* 适用场景
    1. 大内存场景
    2. 要求低延迟的场景